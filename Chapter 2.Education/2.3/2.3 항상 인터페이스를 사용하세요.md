# 항상 인터페이스를 사용하세요.

객체들은 서로를 필요로 하기 때문에 **결합**된다.<br/>
각각의 객체가 어떤 일을 수행하고 다른 객체에게 어떤 서비스를 제공하는 지를 정확하게 알고 있는 편이 낫기 때문에 결합이 유용하다.<br/>
하지만 객체 사이의 **강한 결합도**는 심각한 문제가 될 수 있다.<br/>
결합도 문제는 결국 유지보수성에 영향을 미치게 된다.

유지보수를 가능하도록 만들기 위해서는 객체를 **분리해야 한다.**<br/>
> 객체 분리란<br/>
> 상호작용하는 다른 객체를 수정하지 않고도 해당 객체를 수정할 수 있도록 만든다는 것을 의미한다.

이를 가능하게 해주는 도구가 바로 **인터페이스**(interface)이다.

```java
interface Cash {
    Cash multiply(float factor);
}
```

Cash는 인터페이스이다.<br/>
즉, 우리의 객체가 다른 객체와 의사소통하기 위해 따라야 하는 **계약**(contract)이다.

```java
class DefaultCash implements Cash {
    private int dollars;

    DefaultCash(int dlr) {
        this.dollars = dlr;
    }

    @Override
    Cash multiply(float factor) {
        return new DefaultCash(this.dollars * factor);
    }
}
```

금액이 필요하다면 실제 구현 대신 계약에 의존하면 된다.

```java
class Employee {
    private Cash salary;
}
```

Employee는 Cash의 구현 방법에 아무런 관심이 없다.<br/>
multiply() 메서드가 어떻게 동작하는지도 관심이 없다.<br/>

단, 클래스 안의 모든 퍼블릭 메서드가 인터페이스를 구현하도록 만들어야 한다.<br/>
올바르게 설계된 클래스라면 최소한 하나의 인터페이스라도 구현하지 않는 퍼블릭 메서드를 포함해서는 안된다.

클래스가 존재하는 이유는 다른 누군가가 클래스의 서비스를 필요로 하기 때문이다.<br/>
서비스는 계약이자 인터페이스이기 때문에 클래스가 제공하는 서비스는 어딘가에 문서화되어야 한다.<br/>
각각의 구현체들은 서로 다른 구현체를 쉽게 대체할 수 있어야 한다.<br/>
이것이 **느슨한 결합도**의 의미이다.

> 느낀점<br/>
> 인터페이스로 결합되어 있으면 실제로 구현체가 바뀌더라도 인터페이스를 결합한 클래스에서는 그 구현체가 바뀌었는지 안바뀌었는지는 관심을 가질 필요가 없다.<br/>
> 그냥 내가 값을 넘겼을 때 원하는 결과 값이 나오면 그게 전부이다.<br/>
> 하지만 클래스로 결합할 경우 수정을 해야 할 경우엔 굉장히 많은 수정이 들어가게 된다.<br/>
> 즉, 유지보수성이 떨어지게 된다.<br/>
> 결합을 하되 최대한 느슨하게 결합을 하기 위해서 인터페이스를 사용하는 것이 가장 좋다.

